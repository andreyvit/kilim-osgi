package kilim.osgi;import java.io.ByteArrayInputStream;import java.io.IOException;import java.net.URLConnection;import java.security.ProtectionDomain;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Properties;import kilim.analysis.ClassInfo;import kilim.analysis.ClassWeaver;import org.eclipse.osgi.baseadaptor.BaseAdaptor;import org.eclipse.osgi.baseadaptor.BaseData;import org.eclipse.osgi.baseadaptor.bundlefile.BundleEntry;import org.eclipse.osgi.baseadaptor.hooks.AdaptorHook;import org.eclipse.osgi.baseadaptor.hooks.ClassLoadingHook;import org.eclipse.osgi.baseadaptor.loader.BaseClassLoader;import org.eclipse.osgi.baseadaptor.loader.ClasspathEntry;import org.eclipse.osgi.baseadaptor.loader.ClasspathManager;import org.eclipse.osgi.framework.adaptor.BundleProtectionDomain;import org.eclipse.osgi.framework.adaptor.ClassLoaderDelegate;import org.eclipse.osgi.framework.log.FrameworkLog;import org.eclipse.osgi.internal.loader.BundleLoader;import org.eclipse.osgi.service.resolver.PlatformAdmin;import org.eclipse.osgi.util.ManifestElement;import org.osgi.framework.Bundle;import org.osgi.framework.BundleContext;import org.osgi.framework.BundleException;import org.osgi.framework.Constants;import org.osgi.framework.ServiceReference;import org.osgi.service.packageadmin.PackageAdmin;public class InstrumentationHook implements AdaptorHook, ClassLoadingHook {	private static final String MANIFEST_KEY = "Kilim-Enabled";	private Map<String, byte[]> additionalClasses = new HashMap<String, byte[]>();	static class InstrumentationContext {		public final InstrumentationContext parent;		private final Bundle bundle;		private final String klassName;		public InstrumentationContext(InstrumentationContext parent,				Bundle bundle, String klassName) {			if (bundle == null)				throw new NullPointerException("bundle is null");			if (klassName == null)				throw new NullPointerException("klassName is null");			this.parent = parent;			this.bundle = bundle;			this.klassName = klassName;		}				boolean isBeingInstrumented(String name) {			if (this.klassName.equals(name))				return true;			if (parent != null)				return parent.isBeingInstrumented(name);			else				return false;		}		public Class<?> loadClass(String name) throws ClassNotFoundException {			if (isBeingInstrumented(name))				throw new ClassNotFoundException("It's being instrumented, dude!");			return bundle.loadClass(name);		}	}	private static InstrumentationContext instrumentationContext;	private BundleContext context;	private PackageAdmin packageAdmin;	public static Class<?> loadClass(String name) throws ClassNotFoundException {		return instrumentationContext.loadClass(name);	}	public void frameworkStart(BundleContext context) throws BundleException {		this.context = context;		ServiceReference ref = context.getServiceReference(PackageAdmin.class				.getName());		packageAdmin = (PackageAdmin) context.getService(ref);	}	public void frameworkStop(BundleContext context) throws BundleException {	}	public byte[] processClass(String name, byte[] classbytes,			ClasspathEntry classpathEntry, BundleEntry entry,			ClasspathManager manager) {		try {			Object value = manager.getBaseData().getManifest()					.get(MANIFEST_KEY);			if (value instanceof String && Boolean.parseBoolean((String) value)) {				System.out.println("Instrumenting with Kilim: " + name);				String sn = manager.getBaseData().getSymbolicName();				Bundle[] bundles = packageAdmin.getBundles(sn, null);				if (bundles.length == 0)					throw new AssertionError(							"Could not find instrumented bundle: " + sn);				instrumentationContext = new InstrumentationContext(						instrumentationContext, bundles[0], name);				try {					ClassWeaver weaver = new ClassWeaver(							new ByteArrayInputStream(classbytes));					List<ClassInfo> infos = weaver.getClassInfos();					byte[] result = null;					String nameWithSlashes = name.replace('.', '/');					for (ClassInfo info : infos) {						if (info.className.equals(nameWithSlashes))							result = info.bytes;						else							additionalClasses.put(info.className, info.bytes);					}					if (result == null)						return null;					return result;				} catch (IOException e) {					throw new AssertionError(e);				} finally {					instrumentationContext = instrumentationContext.parent;				}			}		} catch (BundleException e) {			e.printStackTrace();		}		return null;	}	public BaseClassLoader createClassLoader(ClassLoader parent,			ClassLoaderDelegate delegate, BundleProtectionDomain domain,			BaseData data, String[] bundleclasspath) {		BundleLoader loader = (BundleLoader) delegate;		try {			loader.addDynamicImportPackage(ManifestElement.parseHeader(					Constants.DYNAMICIMPORT_PACKAGE, "kilim,kilim.analysis"));		} catch (BundleException be) {			throw new AssertionError(be);		}		return null;	}	// Methods stubs for hooks we do not require:	@SuppressWarnings("unchecked")	public boolean addClassPathEntry(ArrayList cpEntries, String cp,			ClasspathManager hostmanager, BaseData sourcedata,			ProtectionDomain sourcedomain) {		return false;	}	public String findLibrary(BaseData data, String libName) {		return null;	}	public ClassLoader getBundleClassLoaderParent() {		return null;	}	public void initializedClassLoader(BaseClassLoader baseClassLoader,			BaseData data) {	}	public void addProperties(Properties properties) {	}	public FrameworkLog createFrameworkLog() {		return null;	}	public void frameworkStopping(BundleContext context) {	}	public void handleRuntimeError(Throwable error) {	}	public void initialize(BaseAdaptor adaptor) {	}	public URLConnection mapLocationToURLConnection(String location)			throws IOException {		return null;	}	public boolean matchDNChain(String pattern, String[] dnChain) {		return false;	}}